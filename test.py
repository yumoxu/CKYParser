from nltk import Tree
def print_tree(node):
    pass



            # if node.lchild() and node.rchild():
            #     # cur_tree = Tree(node.symbol(), [Tree(node.lchild.symbol(), []), Tree(node.rchild.symbol(), [])])
            #     queue.append(node.lchild())
            #     queue.append(node.rchild())
            # elif node.lchild():
            #     # Tree(node.symbol(), [Tree(node.lchild.symbol(), [])])
            #     queue.append(node.lchild())
            # else:
            #     Tree(node.symbol(), [])

def later_traverse(final_label):
    pass

def front_traverse(final_label):
    # later traverse
    stack = []
    node = final_label
    while node or stack:
        while node:
            print node.symbol()
            stack.append(node)
            node = node.lchild()
        # the leftest child has been processed, now comes to the right child of the latest node
        node = stack.pop()
        node = node.rchild()


def level_traverse(final_label):
    # level traverse
    print 'START level...'
    queue = [final_label]
    while queue:
        node = queue.pop(0)
        print node.symbol()
        lchild = node.lchild()
        rchild = node.rchild()
        if lchild:
            queue.append(lchild)
        if rchild:
            queue.append(rchild)
    print 'END level...'

def firstTree(self):
        '''
            Combine all the subtrees to get the final tree generated by the CKY parser.

        :return: the first tree if the parsing is successful or None.
        '''
        final_label = self.matrix[0][self.n-1].labels()[0]
        if self.grammar.start() == final_label.symbol():
            # Fill all the parent attributes in the tree.
            leaves, stack_1, stack_2 = [], [], []
            # front traverse
            node = final_label
            # print node.lchild()
            stack_1.append(node)
            while stack_1:
                node = stack_1.pop()
                lchild = node.lchild()
                rchild = node.rchild()
                if lchild:
                    lchild.set_parent(node)
                    node.set_lchild(lchild)
                    stack_1.append(node.lchild())
                if rchild:
                    rchild.set_parent(node)
                    node.set_rchild(rchild)
                    stack_1.append(node.rchild())
                stack_2.append(node)
            while stack_2:  # visit
                label = stack_2.pop()
                if not (label.lchild() or label.rchild()):
                    leaves.append(label)
                    print 'label: %s, parent: %s' % (label.symbol(), label.parent().symbol())

            print 'leaves:' + '\t'.join([str(leaf.symbol()) for leaf in leaves])

            tree_list = [(leaf, Tree(leaf.symbol, []), False) for leaf in leaves]  # False: is processed or not
            while len(tree_list) > 1:
                labels = [item[0] for item in tree_list]
                updated_tree_list = []
                for (cur_label, cur_tree, is_processed) in tree_list:
                    if not is_processed:
                        parent_label = cur_label.parent()
                        # find out whether the current label is a left child or a right child
                        is_left = False if parent_label.rchild() == cur_label else True

                        if not parent_label.rchild():  # only one child, update the tuple
                            new_tuple = (parent_label, Tree(parent_label.symbol(), [cur_tree]), False)
                            updated_tree_list.append(new_tuple)
                        # two children and the right one is in the list
                        elif is_left and parent_label.rchild() in labels:
                            # find the right child
                            for i in range(len(tree_list)):
                                if tree_list[i][0] == parent_label.rchild():
                                    r_tree = tree_list[i][1]
                                    tree_list[i][2] = True
                                    # update the current tuple to its parent
                                    new_tuple = (parent_label, Tree(parent_label.symbol(), [cur_tree, r_tree]), False)
                                    updated_tree_list.append(new_tuple)
                        elif (is_left and parent_label.rchild() not in labels) or not is_left:
                            updated_tree_list.append((cur_label, cur_tree, is_processed))
                tree_list = updated_tree_list
            return tree_list[1]  # the final tree
        else:
            return None